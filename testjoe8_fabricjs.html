<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <script src="painter/all.js" ></script>
    <script src="painter/jquery-1.10.2.min.js"></script> 
	
</head>
<body>   
<div id="wrapper">
  <div class="canvas-container">
    <canvas id="c1" width="400" height="200"></canvas>
    <canvas id="c2" width="300" height="300"></canvas>
  </div>
</div>
</body>

<script>

//http://stackoverflow.com/questions/13195481/get-the-canvas-object-while-using-fabric-js
//var x = new fabric.Canvas("mycanvas");
//document.getElementById("mycanvas").fabric = x;
//You can then retrieve that object any time you want with:

//var y = document.getElementById("mycanvas").fabric;
//var url = y.toDataURL("png", 1);

    var c1 = new fabric.Canvas('c1');
    var c2 = new fabric.Canvas('c2');

    $("#c1").parent().css({ "position": "absolute", "top": "300px", "left": "300px", "z-index": "1" });
    $("#c2").parent().css({ "position": "absolute", "top": "350px", "left": "450px", "z-index": "2" });
    c1.calcOffset();
    c2.calcOffset();

    fabric.Image.fromURL('images/pug.jpg', function (img) {
        c1.add(img);
        c1.renderAll();
    });
	
	var ctx = c2.getContext("2d");


fabric.loadSVGFromURL('images/14.svg', function (svg) {
            gg = new fabric.PathGroup(svg);
            /* 
			gg.set({
                left: 200,
                top: 200,
                scaleX: 3.5,
                scaleY: 3.5
            });
			*/

           
            var l = 0; // -((gg.paths[0].width / 2) + gg.paths[0].pathOffset.x);
            var t = 0; // -((gg.paths[0].height / 2) + gg.paths[0].pathOffset.y);
			//ctx.scale(1,1); //支援放大縮小
			//ctx.strokeStyle = "rgb(0,160,212)";
			
			
			ctx.save();
            ctx.beginPath();
			

            for (var j = 0; j < gg.paths.length; j++) {
                

                for (var i = 0, len = gg.paths[j].path.length; i < len; ++i) {
                    current = gg.paths[j].path[i];

                    switch (current[0]) { // first letter

                        case 'l': // lineto, relative
                            x += current[1];
                            y += current[2];
                            ctx.lineTo(x + l, y + t);
                            break;

                        case 'L': // lineto, absolute
                            x = current[1];
                            y = current[2];
                            ctx.lineTo(x + l, y + t);
                            break;

                        case 'h': // horizontal lineto, relative
                            x += current[1];
                            ctx.lineTo(x + l, y + t);
                            break;

                        case 'H': // horizontal lineto, absolute
                            x = current[1];
                            ctx.lineTo(x + l, y + t);
                            break;

                        case 'v': // vertical lineto, relative
                            y += current[1];
                            ctx.lineTo(x + l, y + t);
                            break;

                        case 'V': // verical lineto, absolute
                            y = current[1];
                            ctx.lineTo(x + l, y + t);
                            break;

                        case 'm': // moveTo, relative
                            x += current[1];
                            y += current[2];
                            // draw a line if previous command was moveTo as well (otherwise, it will have no effect)
                            //ctx[(previous && (previous[0] === 'm' || previous[0] === 'M')) ? 'lineTo' : 'moveTo'](x + l, y + t);
                            ctx.moveTo(x + l, y + t);
                            break;

                        case 'M': // moveTo, absolute
                            x = current[1];
                            y = current[2];
                            // draw a line if previous command was moveTo as well (otherwise, it will have no effect)
                            //ctx[(previous && (previous[0] === 'm' || previous[0] === 'M')) ? 'lineTo' : 'moveTo'](x + l, y + t);
                            ctx.moveTo(x + l, y + t);
                            break;

                        case 'c': // bezierCurveTo, relative
                            tempX = x + current[5];
                            tempY = y + current[6];
                            controlX = x + current[3];
                            controlY = y + current[4];
                            ctx.bezierCurveTo(
                  x + current[1] + l, // x1
                  y + current[2] + t, // y1
                  controlX + l, // x2
                  controlY + t, // y2
                  tempX + l,
                  tempY + t
                );
                            x = tempX;
                            y = tempY;
                            break;

                        case 'C': // bezierCurveTo, absolute
                            x = current[5];
                            y = current[6];
                            controlX = current[3];
                            controlY = current[4];
                            ctx.bezierCurveTo(
                  current[1] + l,
                  current[2] + t,
                  controlX + l,
                  controlY + t,
                  x + l,
                  y + t
                );
                            break;

                        case 's': // shorthand cubic bezierCurveTo, relative

                            // transform to absolute x,y
                            tempX = x + current[3];
                            tempY = y + current[4];

                            // calculate reflection of previous control points
                            controlX = controlX ? (2 * x - controlX) : x;
                            controlY = controlY ? (2 * y - controlY) : y;

                            ctx.bezierCurveTo(
                  controlX + l,
                  controlY + t,
                  x + current[1] + l,
                  y + current[2] + t,
                  tempX + l,
                  tempY + t
                );
                            // set control point to 2nd one of this command
                            // "... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point."
                            controlX = x + current[1];
                            controlY = y + current[2];

                            x = tempX;
                            y = tempY;
                            break;

                        case 'S': // shorthand cubic bezierCurveTo, absolute
                            tempX = current[3];
                            tempY = current[4];
                            // calculate reflection of previous control points
                            controlX = 2 * x - controlX;
                            controlY = 2 * y - controlY;
                            ctx.bezierCurveTo(
                  controlX + l,
                  controlY + t,
                  current[1] + l,
                  current[2] + t,
                  tempX + l,
                  tempY + t
                );
                            x = tempX;
                            y = tempY;

                            // set control point to 2nd one of this command
                            // "... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point."
                            controlX = current[1];
                            controlY = current[2];

                            break;

                        case 'q': // quadraticCurveTo, relative
                            // transform to absolute x,y
                            tempX = x + current[3];
                            tempY = y + current[4];

                            controlX = x + current[1];
                            controlY = y + current[2];

                            ctx.quadraticCurveTo(
                  controlX + l,
                  controlY + t,
                  tempX + l,
                  tempY + t
                );
                            x = tempX;
                            y = tempY;
                            break;

                        case 'Q': // quadraticCurveTo, absolute
                            tempX = current[3];
                            tempY = current[4];

                            ctx.quadraticCurveTo(
                  current[1] + l,
                  current[2] + t,
                  tempX + l,
                  tempY + t
                );
                            x = tempX;
                            y = tempY;
                            controlX = current[1];
                            controlY = current[2];
                            break;

                        case 't': // shorthand quadraticCurveTo, relative

                            // transform to absolute x,y
                            tempX = x + current[1];
                            tempY = y + current[2];


                            if (previous[0].match(/[QqTt]/) === null) {
                                // If there is no previous command or if the previous command was not a Q, q, T or t,
                                // assume the control point is coincident with the current point
                                controlX = x;
                                controlY = y;
                            }
                            else if (previous[0] === 't') {
                                // calculate reflection of previous control points for t
                                controlX = 2 * x - tempControlX;
                                controlY = 2 * y - tempControlY;
                            }
                            else if (previous[0] === 'q') {
                                // calculate reflection of previous control points for q
                                controlX = 2 * x - controlX;
                                controlY = 2 * y - controlY;
                            }

                            tempControlX = controlX;
                            tempControlY = controlY;

                            ctx.quadraticCurveTo(
                  controlX + l,
                  controlY + t,
                  tempX + l,
                  tempY + t
                );
                            x = tempX;
                            y = tempY;
                            controlX = x + current[1];
                            controlY = y + current[2];
                            break;

                        case 'T':
                            tempX = current[1];
                            tempY = current[2];

                            // calculate reflection of previous control points
                            controlX = 2 * x - controlX;
                            controlY = 2 * y - controlY;
                            ctx.quadraticCurveTo(
                  controlX + l,
                  controlY + t,
                  tempX + l,
                  tempY + t
                );
                            x = tempX;
                            y = tempY;
                            break;

                        case 'a':
                            // TODO: optimize this
                            drawArc(ctx, x + l, y + t, [
                  current[1],
                  current[2],
                  current[3],
                  current[4],
                  current[5],
                  current[6] + x + l,
                  current[7] + y + t
                ]);
                            x += current[6];
                            y += current[7];
                            break;

                        case 'A':
                            // TODO: optimize this
                            drawArc(ctx, x + l, y + t, [
                  current[1],
                  current[2],
                  current[3],
                  current[4],
                  current[5],
                  current[6] + l,
                  current[7] + t
                ]);
                            x = current[6];
                            y = current[7];
                            break;

                        case 'z':
                        case 'Z':                            
                            break;
                    }
                }
            }

			ctx.closePath();			
            ctx.stroke();
            ctx.clip();
			
			
        });

    fabric.Image.fromURL('images/butterfly.jpg', function (img) {
		
		c2.add(img);
		c2.renderAll();
        
    });

    c1.observe("mouse:up", function () {
        //alert("mouse on canvas 1");
        c1.calcOffset();
    });

    c2.observe("mouse:up", function () {
        //alert("mouse on canvas 2");
        c2.calcOffset();
    });
</script>

</html>
